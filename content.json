{"meta":{"title":"Hexo","subtitle":"","description":"","author":"ky2fe","url":"https://ky11fe.gitee.io/blog","root":"/blog/"},"pages":[{"title":"文章分类","date":"2021-09-04T07:41:35.000Z","updated":"2021-09-04T07:42:18.770Z","comments":true,"path":"categories/index.html","permalink":"https://ky11fe.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"你好","date":"2021-11-07T08:51:00.000Z","updated":"2021-11-13T08:29:27.715Z","comments":true,"path":"about/index.html","permalink":"https://ky11fe.gitee.io/blog/about/index.html","excerpt":"","text":"我是一个在校大学生，此博客用于记录日常一些项目的学习和问题的解决，仅此而已。"},{"title":"文章标签","date":"2021-09-04T07:42:38.000Z","updated":"2021-09-04T07:43:01.995Z","comments":true,"path":"tags/index.html","permalink":"https://ky11fe.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"shiro整合springboot","slug":"shiro整合springboot","date":"2021-11-13T08:00:50.000Z","updated":"2021-11-13T08:37:39.962Z","comments":true,"path":"2021/11/13/shiro整合springboot/","link":"","permalink":"https://ky11fe.gitee.io/blog/2021/11/13/shiro%E6%95%B4%E5%90%88springboot/","excerpt":"shiro 是一个功能强大和易于使用的Java安全框架，为开发人员提供一个直观而全面的解决方案的认证，授权，加密，会话管理。","text":"shiro 是一个功能强大和易于使用的Java安全框架，为开发人员提供一个直观而全面的解决方案的认证，授权，加密，会话管理。 一、shiro是什么shiro 是一个功能强大和易于使用的Java安全框架，为开发人员提供一个直观而全面的解决方案的认证，授权，加密，会话管理。 二、功能功能图： Authentication：身份认证/登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，判断某个已经认证过的用户是否拥有某些权限访问某些资源，一般授权会有角色授权和权限授权； SessionManager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的，web 环境中作用是和 HttpSession 是一样的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储 ![Untitled Diagram.drawio](D:\\下载\\浏览器Download\\Untitled Diagram.drawio.png) 三、架构 不管是任何请求都会经过 SecurityManager 拦截并进行相应的处理，shiro 几乎所有的功能都是由 SecurityManager 来管理 Subject：主体，相当与是请求过来的”用户“ SecurityManager： 是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行拦截并控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理 Authenticator：认证器，负责主体认证的，即确定用户是否登录成功，我们可以使用 Shiro 提供的方法来认证，有可以自定义去实现，自己判断什么时候算是用户登录成功 Authrizer：授权器，即权限授权，给 Subject 分配权限，以此很好的控制用户可访问的资源 Realm：一般我们都需要去实现自己的 Realm ，可以有1个或多个 Realm，即当我们进行登录认证时所获取的安全数据来源(帐号/密码) SessionManager：为了可以在不同的环境下使用 session 功能，shiro 实现了自己的 sessionManager ，可以用在非 web 环境下和分布式环境下使用 SessionDAO：对 session 的 CURD 操作 CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的； Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。 四、主要功能解析1.认证Subject 认证 身份认证就是在应用中谁能证明他就是他本人,一般会使用用户名和密码作为认证信息。 Subject认证主体 **Principals:**身份,即用户名 **Credentials:**凭证,即密码 认证流程 用户发送请求进行 Subject 认证(调用 subject.login(token)) SecurityManager 会去 Authenticator(认证器)中查找相应的 Realms(可能不止一个)源 Realms 可以根据不同类型的 Realm 中去查找用户信息,并进行判断是否认证成功 2.授权 权限授权就是访问控制,在应用中控制谁能访问哪些资源 认证中的几个元素 权限：即操作某个资源的权限，这些资源可以是某个链接，也可以是某个图片，也可以是对某个模块的数据的 CURL 角色：即权限的集合，一个角色可以有多个权限 用户：代表访问的用户，即 Subject 流程图： 当用户访问应用中的某个资源时，会被 SecurityManager 拦截. SecurityManager 会去调用 Authorizer(授权器) Authorizer 会根据 Subject 的身份去相应的 Realm 中去查找该 Subject 是否有权限去访问该资源 3.shiro内置过滤器 anon：无需认证即可访问（游客） authc：认证之后才可访问 user：设置记住我选项后才能访问 perms：拥有对某个资源的权限才能访问 role：拥有某角色才能访问 五、代码1.导包 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.7.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha4&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha4&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 2.shiro.ini 123456789101112131415161718192021222324252627[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on# my luggage!!!&quot; ;)), and role &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;darkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions## Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc# -----------------------------------------------------------------------------[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with# license plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5 六、subject关于当前用户的主要代码 1234567Subject currentUser = SecurityUtils.getSubject();Session session = currentUser.getSession();!currentUser.isAuthenticated();currentUser.login(token);currentUser.hasRole(&quot;schwartz&quot;)currentUser.isPermitted(&quot;lightsaber:wield&quot;)currentUser.logout(); 七、整合springboot-web配置类 1234567891011121314151617181920212223@Configurationpublic class ShiroConfig &#123; public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); //绑定securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); return shiroFilterFactoryBean; &#125; @Bean(name = &quot;securityManager&quot;) public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) ShiroUserRealm userRealm)&#123; DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager(); //securityManager要关联Realm defaultWebSecurityManager.setRealm(userRealm); return defaultWebSecurityManager; &#125; @Bean public ShiroUserRealm userRealm()&#123; return new ShiroUserRealm(); &#125;&#125; realm需要另外创建类 12345678910111213public class ShiroUserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; return null; &#125;&#125; 配置过滤器 12345Map&lt;String, String&gt; filterMap=new LinkedHashMap&lt;&gt;();filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);//需要认证后登录filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);//拦截并重定向到登录页面 简易验证账号密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ling.springshiro.config;/** * Created by Ky2Fe on 2021/9/21 15:58 */import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author: Ky2Fe * @program: shiro * @description: SHIRO的realm对象 **/public class ShiroUserRealm extends AuthorizingRealm&#123; private static final String USERNAME=&quot;root&quot;; private static final String PASSWORD=&quot;123456&quot;; /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;执行授权&quot;); return null; &#125; /** * 认证 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; System.out.println(&quot;执行认证&quot;); UsernamePasswordToken userToken= (UsernamePasswordToken) authenticationToken; if (!userToken.getUsername().equals(USERNAME))&#123; return null;//抛出UnknownAccountException异常 &#125; return new SimpleAuthenticationInfo(&quot;&quot;,PASSWORD,&quot;&quot;); &#125;&#125; shiro密码加密 shiro中密码不为明文传输，加密方法由shiro完成 授权操作 授权操作先在config中设置访问某个地址所需要的权限，之后在realm的授权方法中检查用户权限 1234567System.out.println(&quot;执行授权&quot;);SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();Subject subject = SecurityUtils.getSubject();User currentUser = (User) subject.getPrincipal();//当前页面需要什么权限在config中已经设置好，这里检查用户是否有该权限，这里也可以换成角色，再给每个角色配置权限（在数据库中）info.addStringPermission(currentUser.getPerms());return info; 推荐使用角色操作（role）","categories":[{"name":"后端","slug":"后端","permalink":"https://ky11fe.gitee.io/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://ky11fe.gitee.io/blog/tags/springboot/"},{"name":"shiro","slug":"shiro","permalink":"https://ky11fe.gitee.io/blog/tags/shiro/"},{"name":"登录","slug":"登录","permalink":"https://ky11fe.gitee.io/blog/tags/%E7%99%BB%E5%BD%95/"}]},{"title":"高并发解决方案","slug":"高并发解决方案","date":"2021-09-04T08:13:56.000Z","updated":"2021-11-09T09:03:12.554Z","comments":true,"path":"2021/09/04/高并发解决方案/","link":"","permalink":"https://ky11fe.gitee.io/blog/2021/09/04/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"成熟的秒杀解决方案应该是高可用高并发的，其中主要解决高并发产生的延迟和库存超算的问题，数据库设计和redis缓存是一般解决中非常重要的部分，RabbitMQ消息对列可以大大提高系统应答速度，使前端更加友好，并大大提高后端性能","text":"成熟的秒杀解决方案应该是高可用高并发的，其中主要解决高并发产生的延迟和库存超算的问题，数据库设计和redis缓存是一般解决中非常重要的部分，RabbitMQ消息对列可以大大提高系统应答速度，使前端更加友好，并大大提高后端性能 页面优化页面优化部分，如果项目开始即使用前后端分离模式，便不用进行缓存设计，页面优化部分基本上是将后端需要传送的数据放入redis缓存，使前端页面加载更加迅速 接口优化 redis预减库存+内存标记减少redis访问 123456789101112private Map&lt;Long,Boolean&gt; emptyStockMap =new HashMap&lt;&gt;();//内存标记，减少redis访问if (emptyStockMap.get(goodsId))&#123; return Result.error(ResultEnum.EMPTY_STOCK);&#125;//预减库存操作Long stock = valueOperations.decrement(&quot;seckillGoods:&quot; + goodsId);if (stock&lt;0)&#123; valueOperations.increment(&quot;seckillGoods:&quot; + goodsId); emptyStockMap.put(goodsId,true); return Result.error(ResultEnum.EMPTY_STOCK);&#125; 2.集成rabbitmq消息队列异步下单（采用topic模式） RabbitMqConfig.java 12345678910111213141516171819private static final String QUEUE=&quot;seckillQueue&quot;;private static final String EXCHANGE=&quot;secKillExchange&quot;;private static final String ROUTING_KEY=&quot;seckill.#&quot;;@Beanpublic Queue queue()&#123; return new Queue(QUEUE);&#125;@Beanpublic TopicExchange seckillExchange()&#123; return new TopicExchange(EXCHANGE);&#125;@Beanpublic Binding binding()&#123; return BindingBuilder.bind(queue()).to(seckillExchange()).with(ROUTING_KEY);&#125; MQSender.java 1234567@Autowiredprivate RabbitTemplate rabbitTemplate;public void sendSeckillMessage(String message)&#123; log.info(&quot;发送消息&quot;+message); rabbitTemplate.convertAndSend(&quot;secKillExchange&quot;,&quot;seckill.message&quot;,message);&#125; MQReceiver 1234567891011121314151617@RabbitListener(queues = &quot;seckillQueue&quot;)public void receiver(String message)&#123; log.info(&quot;接收消息：&quot; + message); SeckillMessage seckillMessage = JsonUtil.jsonStr2Object(message, SeckillMessage.class); Long goodsId = seckillMessage.getGoodsId(); User user = seckillMessage.getUser(); GoodsVo goodsVo = goodsService.findGoodsVoByGoodsId(goodsId); if (goodsVo.getStockCount()&lt;1)&#123; return; &#125; SeckillOrder seckillOrder = (SeckillOrder) redisTemplate.opsForValue().get(&quot;order:&quot; + user.getId() + &quot;:&quot; + goodsId); if (seckillOrder!=null)&#123; return; &#125; //下单操作 orderService.secKill(user,goodsVo);&#125; 安全优化1.秒杀接口地址隐藏 基本上就是原来的秒杀post操作的地址变成获取post操作地址的地址 创建地址 123456789101112/** * 创建地址 * @param user * @param goodsId * @return */@Overridepublic String createPath(User user, Long goodsId) &#123; String str = MD5Util.md5(UUIDUtil.uuid() + &quot;123456&quot;); redisTemplate.opsForValue().set(&quot;seckillPath:&quot;+user.getId()+&quot;:&quot;+goodsId,str,60, TimeUnit.SECONDS); return str;&#125; 地址校验 123456789101112131415/** * 接口地址校验 * @param user * @param goodsId * @param path * @return */@Overridepublic boolean checkPath(User user, Long goodsId, String path) &#123; if (null==user||goodsId&lt;0|| !StringUtils.hasLength(path))&#123; return false; &#125; String redisPath = (String) redisTemplate.opsForValue().get(&quot;seckillPath:&quot; + user.getId() + &quot;:&quot; + goodsId); return path.equals(redisPath);&#125; 以上操作的地址都存储在redis中 验证码 主要是生成验证码并通过验证才能进行秒杀，验证码可以在github上或者码云上找 总结成熟的秒杀解决方案应该是高可用高并发的，其中主要解决高并发产生的延迟和库存超算的问题，数据库设计和redis缓存是一般解决中非常重要的部分，RabbitMQ消息对列可以大大提高系统应答速度，使前端更加友好，并大大提高后端性能","categories":[{"name":"后端","slug":"后端","permalink":"https://ky11fe.gitee.io/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://ky11fe.gitee.io/blog/tags/springboot/"},{"name":"高并发","slug":"高并发","permalink":"https://ky11fe.gitee.io/blog/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"redis","slug":"redis","permalink":"https://ky11fe.gitee.io/blog/tags/redis/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://ky11fe.gitee.io/blog/tags/rabbitmq/"},{"name":"mysql","slug":"mysql","permalink":"https://ky11fe.gitee.io/blog/tags/mysql/"},{"name":"maven","slug":"maven","permalink":"https://ky11fe.gitee.io/blog/tags/maven/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://ky11fe.gitee.io/blog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://ky11fe.gitee.io/blog/tags/springboot/"},{"name":"shiro","slug":"shiro","permalink":"https://ky11fe.gitee.io/blog/tags/shiro/"},{"name":"登录","slug":"登录","permalink":"https://ky11fe.gitee.io/blog/tags/%E7%99%BB%E5%BD%95/"},{"name":"高并发","slug":"高并发","permalink":"https://ky11fe.gitee.io/blog/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"redis","slug":"redis","permalink":"https://ky11fe.gitee.io/blog/tags/redis/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://ky11fe.gitee.io/blog/tags/rabbitmq/"},{"name":"mysql","slug":"mysql","permalink":"https://ky11fe.gitee.io/blog/tags/mysql/"},{"name":"maven","slug":"maven","permalink":"https://ky11fe.gitee.io/blog/tags/maven/"}]}